import { WorldSchema } from './schemas';

export const WorldParser = {
    /**
     * Validates and parses the raw JSON from the LLM.
     * @param {object} rawJson - The JSON object returned by the AI.
     * @returns {object} - The validated and sanitized world data.
     * @throws {Error} - If validation fails.
     */
    parse(rawJson) {
        console.log("WorldParser: Parsing world data...", rawJson);

        const result = WorldSchema.safeParse(rawJson);

        if (!result.success) {
            console.error("WorldParser: Validation Failed", result.error.format());
            throw new Error("World Generation Failed: Invalid Schema");
        }

        return result.data.world;
    },

    /**
     * Flattens the hierarchical world data into a list of entities for the renderer.
     * This is a helper to bridge the Data Layer and Builder Layer.
     * @param {object} worldData - Validated world data.
     */
    flattenEntities(worldData) {
        const entities = [];

        worldData.zones.forEach(zone => {
            // Zone Offset
            const zoneX = zone.x;
            const zoneZ = zone.z;

            zone.rooms.forEach(room => {
                // Room Offset (relative to Zone)
                const roomX = zoneX + room.x;
                const roomZ = zoneZ + room.z;

                // Walls (Abstracted for now, usually generated by Builder)
                // Furniture
                room.furniture.forEach(item => {
                    entities.push({
                        id: item.id || `furn_${Math.random().toString(36).substr(2, 9)}`,
                        type: "furniture",
                        name: item.name,
                        x: roomX + item.x,
                        z: roomZ + item.z,
                        rotation: item.rotation
                    });
                });

                // Clues
                room.clues.forEach(clue => {
                    entities.push({
                        id: clue.id,
                        type: "clue",
                        name: clue.type, // Map type to name for registry lookup
                        description: clue.description,
                        x: roomX + clue.x,
                        z: roomZ + clue.z
                    });
                });
            });
        });

        return entities;
    }
};
